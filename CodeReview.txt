    The interface for the MusicEditorModel and the Playable classes we were given could be easily adapted to work with our Model and provided the flexibility in order to implement the features that were required and we had in our previous assignment.  The class architecture of the view package was designed in a way that allowed for the delegation of tasks to their respective subclasses, therefore improving general readability and protection of data.
    The overall readability/security/efficiency of the code was reduced due to logical errors, such as mathematical mistakes, unnecessary for-loops, and inconsistent field usage.  Within ConcreteGuiViewPanel, when the paintComponent() method drew the notes there was an instance of three nested for-loops.  While the issue of this running in n^n^n time is not a huge issue for smaller/medium size projects such as this assignment, it's still very inefficient when scaled up.  This issue was very easily fixed, as one of the loops repeated a previous one and was unnecessary - for each note at a beat, it looped through all the pitch values at that beat - and therefore allowed that section to be reduced to only two nested loops (this change was requested and implemented).  
    There were often fields created both in the class itself or within a method that were never used or were used inconsistently. For example, in the ConcreteGuiViewPanel class within the paintComponent(Graphics g) method, int finalBeatNumber = model.lastBeat() was stated towards the top of the method body. At some points within the method, finalBeatNumber is used and others model.lastBeat() is used. lowestPitch, pitchLength, and maxNotes were created but never used. Another factor that made the code difficult to follow was all of the magic numbers. In the ConcreteGuiViewPanel, there are a lot of * 12, + 11, -1 that don't have any comments explaining the logic behind the adjustments. Some numbers were pulled out into static fields which was convenient, but unfortunately, they were package private and instead of making them public (there were accessor methods used to retrieve them when they were needed in other classes). 
Methods also sometimes had Javadoc that was misleading/confusing (See example below):

/**
* Returns the string representation of a note's pitch particularly for the view's String
* representations of the pitches of an octave
*
* @return String representation of the musical composition
* @throws IllegalArgumentException when an inapplicable String is not valid for a musical piece
*/
String printBase();

The above method was in the provided Model interface. We were unsure how a method called on a Model could return a single note's pitch without taking an argument. Furthermore, it also wasn't clear how it could throw an IllegalArgumentException when the method doesn’t take any arguments. 
    The provided Views had an instance of a Model as one of its fields which created a tight link between the two. The three pieces of the Model-View-Controller strategy shouldn’t be directly linked because by doing so, there is the possibility of creating a cycle. Also, by having direct access to the model, unintended mutations can occur as the entire Model interface is available to the View. In order to fix this, Views should take an encapsulated version of the Model which has a limited set of methods that only allow the View to look at the Model and not interact with it as interaction with the Model should be handled by the Controller (at least for this assignment).
    The view is also required to be represented by fixed octaves, meaning it was centered around C5 and did not allow for other interpretations of the range of octaves.  Obviously, in the end the MIDI values go from 0-127, but depending on the group the octave numbers could have started at 0, -1, or even -2 and still represented all the necessary note values.  Their GuiView required the model's octaves to conform to their interpretation of MIDI's octave range - we were able to work around this issue.
    During our testing and debugging the MIDI component of the CompositeView, we encountered a few trivial errors. When the music was being played, all the notes had a very long echo and did not truly stop playing their respective sounds at what should be the end of the note when we watched the red line follow the them.  We found that this was caused by the timestamp of the "OFF" message within the playNote() method, where there is a "200000000" (== 200 seconds).  Going off of the implementation of how the midi messages are being sent, the "OFF" messages should be sent and activated immediately, meaning that the timestamp value should be -1 (it will perform this action immediately).  This change was requested and implemented.  
    Also, when the program is run, the initialize() method found in the MidiView is called. This method contains an instance of playNote(), which causes the first beat’s worth of notes to be played before the spacebar is hit (what we're using to play/pause the audio playback). Then, when we want to play the piece, it starts at beat 2 and continues normally from there. We suggested deleting the try/catch containing this instance of playNote() because it fixed this error, so when we hit the spacebar it starts playing the music from beat 1 and on.  We are assuming that this is because our controller is implemented as being initially paused, while theirs is likely initialized to play the piece immediately.  This change was requested, but not implemented.
    We had also noticed that in the updateTime(...) method contains "currTime++," which to implied that each method in their views that required access to a timer incremented individually and were driven by an overarching method that called each of these update methods.  It makes more sense to have the time data stored in the controller to ensure that all the methods in the program that rely on that value are in sync, since they'd refer to that one instance of the time value.  We suggested that updateTime() be modified so it has a time value for an input, which would allow access for another method to set the current time of the piece to a given beat, which we felt was a more secure way to increment the time as well as a very useful feature.  This change was implemented, but the "currTime++" line was not removed, but the functionality of our code is not affected by this.
** CHANGES MADE **
updateTime(int Time) now takes an input to keep the MIDI in sync with the controller's universal timer 
no fixed height to allow the view to expand vertically rather than being fixed at 1000 pixels
MIDI "OFF" message timestamp
removed extra for-loop in ConcreteGuiViewPanel